/* * mm_camera_interface2.c * 这个文件提供进入mm-camera的接口，功能如其名称所述。 * * 该文件的大致结构如下： *	1. 提供一个全局变量(g_cam_ctrl)作为所有摄像头实例的总控 *	2. 对上： 为 QCameraHardwareInterface 对象(QCameraHWI.cpp)提供接口(如cam_ops_open函数) *	3. 对下： 调用mm_camera_t对象(代表mm-camera对象)的接口(如mm_camera_open函数)完成具体功能 */// 一、全景变量：g_cam_ctrl对象// 二、对上，为QCameraHardwareInterface对象提供接口// 三、对下，调用mm_camera_t对象的接口来完成具体功能// 四、以open操作为例，流程大致如下：[@hardware/qcom/camera/QCameraHWI.cpp]QCamearHardwareInterface(int cameraId, int mode) {	// ...	result = cam_ops_open(mCameraId, MM_CAMERA_OP_MODE_NOTUSED);	// ...}// cam_ops_open()函数为mm_camera_interface2.c为上层提供的接口[@hardware/qcom/camera/mm_camera_interface2.c]int32_t cam_ops_open(int cam_id, mm_camera_op_mode_type_t op_mode) {	// 首先，从全景变量中找到mm-camera对应的对象：mm_cam	// 见：A, B, C 三步操作	mm_camera_t *mm_cam = get_camera_by_id(cam_id);	if(mm_cam) {		// 然后，调用mm-camera对象的接口来完成具体功能		mm_cam->ops->open(mm_cam, op_mode);	}}///////////// A.[@hardware/qcom/camera/mm_camera_interface2.c]static mm_camera_t *get_camera_by_id(int cam_id) {	mm_camera_t *mm_cam;	mm_cam = *g_cam_ctrl.camera[cam_id];	return mm_cam;}///////////// B.[@hardware/qcom/camera/mm_camera_interface2.c]extern mm_camera_t *mm_camera_query(uint8_t num_cameras) {	// ...	g_cam_ctrl.camera[i].ops = &mm_camera_ops;	// ...}///////////// C.[@hardware/qcom/camera/mm_camera_interface2.c]static mm_camera_ops_t mm_camera_ops = {	// ...	.open = mm_camera_ops_open,	// ...}// mm_camera_ops_open()对应的即为.open函数，它调用到mm-camera里面去了[@hardware/qcom/camera/mm_camera_interface2.c]static int32_t mm_camera_ops_open(mm_camera_t *camera, mm_camera_op_mode_type_t op_mode) {	// ...	rc = mm_camera_open(g_cam_ctrl.cam_obj[camera_id], op_mode);	// ...}[@hardware/qcom/camera/mm_camera.c]int32_t mm_camera_open(mm_camera_obj_t *my_obj, mm_camera_op_mode_type_t op_mode) {	// ...	snprintf(dev_name, sizeof(dev_name), "/dev/%s", mm_camera_util_get_dev_name(my_obj));	// ...	my_obj->ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK);}