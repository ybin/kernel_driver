/* * mm_camera_interface2.c * 这个文件提供进入mm-camera的接口，功能如其名称所述。 * * 该文件的大致结构如下： *	1. 提供一个全局变量(g_cam_ctrl)作为所有摄像头实例的总控 *	2. 对上： 为 QCameraHardwareInterface 对象(QCameraHWI.cpp)提供接口(如cam_ops_open函数) *	3. 对下： 调用mm_camera_t对象(代表mm-camera对象)的接口(如mm_camera_open函数)完成具体功能 * * 该文件的总体结构就是： *	high level layer(e.g. camera_device_t) ==> *		cam_xxx_yyy() 组函数接口 ==> *			g_cam_ctrl_t 查找相关数据结构 ==> *				mm_camera_xxx_yyy() 组函数接口 */// 一、全景变量：g_cam_ctrl对象static mm_camera_ctrl_t g_cam_ctrl;typedef struct {	mm_camera_t camera[MSM_MAX_CAMERA_SENSORS];	int8_t num_cam;	char video_dev_name[MSM_MAX_CAMERA_SENSORS][MM_CAMERA_DEV_NAME_LEN];	mm_camera_obj_t *cam_obj[MSM_MAX_CAMERA_SENSORS];} mm_camera_ctrl_t;/* * mm_camera_ctrl_t 结构主要包括两部分： *	a. mm_camera_t 结构 *		该结构是底层 mm_camera 的代表对象，主要包括 config, ops, notify, jpeg 四组操作接口 *		和 camera_info_t 结构(包括 sensor 的安装角度，camera id 等几个信息) *	b. mm_camera_obj_t 结构 *		该结构包括了各种操作信息，暂时不清楚具体作用 */// 初始化[代码已删减]extern mm_camera_t *mm_camera_query(uint8_t *num_cameras) {	int server_fd = 0;	// 用于保存 query 到的信息，这些信息将用来初始化 g_cam_ctrl 对象	struct msm_camera_info cameraInfo;		*num_cameras = 0;	// 此时 g_cam_ctrl 的内容为空	for(i = 0; i < MSM_MAX_CAMERA_SENSORS; i++) {		cameraInfo.video_dev_name[i] = g_cam_ctrl.video_dev_name[i];	}	server_fd = open(MSM_CAMERA_SERVER, O_RDWR);	rc = ioctrl(server_fd, MSM_CAM_IOCTL_GET_CAMERA_INFO, &cameraInfo);	// 开始初始化 g_cam_ctrl 对象	for(i=0; i<cameraInfo.num_cameras; i++) {		// 设置 camera_info 字段		g_cam_ctrl.camera[i].camera_info.camera_id = i;		g_cam_ctrl.camera[i].camera_info.modes_supported = (!cameraInfo.has_3d_supported[i]) ? CAMERA_MODE_2D : RA_MODE_2D | CAMERA_MODE_3D;		g_cam_ctrl.camera[i].camera_info.position = (cameraInfo.is_internal_cam[i]) ? FRONT_CAMERA : BACK_CAMERA;		g_cam_ctrl.camera[i].camera_info.sensor_mount_angle = cameraInfo.s_mount_angle[i];				g_cam_ctrl.camera[i].video_dev_name = (char *)cameraInfo.video_dev_name[i];		g_cam_ctrl.camera[i].sensor_type = cameraInfo.sensor_type[i];		// 设置 config、ops、callback、jpeg 操作接口，这些接口都是 mm-camera 提供的，用以完成具体的功能		g_cam_ctrl.camera[i].cfg = &mm_camera_cfg;		g_cam_ctrl.camera[i].ops = &mm_camera_ops;		g_cam_ctrl.camera[i].evt = &mm_camera_notify;		g_cam_ctrl.camera[i].jpeg_ops = NULL;	}		*num_cameras = cameraInfo.num_cameras;	g_cam_ctrl.num_cam = *num_cameras;}// 二、对上，为QCameraHardwareInterface对象提供接口/* * 接口函数分为 4 类： *	a. cam_config_xxx *	b. cam_ops_xxx *	c. cam_evt_xxx *	d. cam_jpeg_xxx */// 三、对下，调用mm_camera_t对象的接口来完成具体功能/* * 接口函数同样分为 4 类： *	a. mm_camera_cfg_xxx *	b. mm_camera_ops_xxx *	c. mm_camera_notify_xxx *	d. mm_camera_jpeg_xxx */ // P.S. 另外该文件中还提供了两个辅助函数： mm_camera_query(): 取得camera module信息//										get_camera_by_id(): 在 g_cam_ctrl 全局对象中查找当前 id 代表的camera对象// 四、以open操作为例，流程大致如下：[@hardware/qcom/camera/QCameraHWI.cpp]QCamearHardwareInterface(int cameraId, int mode) {	// ...	result = cam_ops_open(mCameraId, MM_CAMERA_OP_MODE_NOTUSED);	// ...}// cam_ops_open()函数为mm_camera_interface2.c为上层提供的接口[@hardware/qcom/camera/mm_camera_interface2.c]int32_t cam_ops_open(int cam_id, mm_camera_op_mode_type_t op_mode) {	// 首先，从全景变量中找到mm-camera对应的对象：mm_cam	// 见：A, B, C 三步操作	mm_camera_t *mm_cam = get_camera_by_id(cam_id);	if(mm_cam) {		// 然后，调用mm-camera对象的接口来完成具体功能		mm_cam->ops->open(mm_cam, op_mode);	}}///////////// A.[@hardware/qcom/camera/mm_camera_interface2.c]static mm_camera_t *get_camera_by_id(int cam_id) {	mm_camera_t *mm_cam;	mm_cam = *g_cam_ctrl.camera[cam_id];	return mm_cam;}///////////// B.[@hardware/qcom/camera/mm_camera_interface2.c]extern mm_camera_t *mm_camera_query(uint8_t num_cameras) {	// ...	g_cam_ctrl.camera[i].ops = &mm_camera_ops;	// ...}///////////// C.[@hardware/qcom/camera/mm_camera_interface2.c]static mm_camera_ops_t mm_camera_ops = {	// ...	.open = mm_camera_ops_open,	// ...}// mm_camera_ops_open()对应的即为.open函数，它调用到mm-camera里面去了[@hardware/qcom/camera/mm_camera_interface2.c]static int32_t mm_camera_ops_open(mm_camera_t *camera, mm_camera_op_mode_type_t op_mode) {	// ...	rc = mm_camera_open(g_cam_ctrl.cam_obj[camera_id], op_mode);	// ...}[@hardware/qcom/camera/mm_camera.c]int32_t mm_camera_open(mm_camera_obj_t *my_obj, mm_camera_op_mode_type_t op_mode) {	// ...	snprintf(dev_name, sizeof(dev_name), "/dev/%s", mm_camera_util_get_dev_name(my_obj));	// ...	my_obj->ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK);}